#include "ddm.hpp"

#include <immintrin.h>
#include <tinytiffwriter.h>
#include <omp.h>
#include <fftw3.h>

#include <cmath>
#include <ranges>
#include <fstream>
#include <iostream>
#include <vector>

#include "utils.hpp"
#include "timer.hpp"


// À faire
// - Merge les calculs de DDM avec le meme spacing


DDM::DDM(Stack* stack, utils::Options& options) : options(*(new utils::Options)) {

    /**
     * Comment generated by GPT-3
     *
     * Construct a DDM object using a Stack and specified options.
     *
     * This constructor initializes a DDM object based on the provided Stack and options. It performs the following steps:
     *   1. Initializes FFTW threads and sets the number of threads.
     *   2. Creates an FFTW plan for the given Stack, performing a real-to-complex discrete Fourier transform (DFT).
     *   3. Computes DDM differences using the FFT results, considering options such as log scale and vectorization.
     *   4. Mirrors DDM images to center the zero frequency, resulting in a square DDM buffer.
     *
     * @param stack A pointer to the Stack object containing input data.
     * @param options Reference to the Options structure specifying parameters for DDM computation.
     *
     * Details:
     *   - Uses FFTW for efficient Fourier transforms.
     *   - The DDM buffer dimensions depend on the options and input Stack dimensions.
     *   - The DDM differences are computed based on options, considering log scale and vectorization.
     *   - The final DDM buffer is mirrored to center the zero frequency.
     */

    Timer timer;
    this->options = options;

    std::cout << "* Creating FFTW plan with " << omp_get_max_threads() << " threads..." << std::flush;

    int r = fftwf_init_threads();
    if(r == 0)
        throw std::runtime_error("Can't spawn threads");

    timer.start();
    fftwf_plan_with_nthreads(omp_get_max_threads());

    this->raw_ddm_width = stack->aoi_width/2+1;
    this->raw_ddm_height = stack->aoi_height;

    int rank = 2;

    int n_in[] = {stack->aoi_height, stack->aoi_width};
    int n_out[] = {raw_ddm_width, stack->aoi_width/2+1};

    int fft_size = n_out[0] * n_out[1];

    fftwf_complex* stack_fft  = fftwf_alloc_complex(fft_size * this->options.loadNframes);
    fftwf_plan plan = fftwf_plan_many_dft_r2c(rank, n_in, this->options.loadNframes,
                                              stack->images, n_in,
                                              1, stack->image_size,
                                              stack_fft, n_out,
                                              1, fft_size,
                                              FFTW_ESTIMATE);
    std::cout << "  " << timer.elapsedSec() << "s" << std::endl;


    std::cout << "* Performing DFT..." << std::flush;
    timer.start();
    fftwf_execute(plan);
    std::cout << "                     " << timer.elapsedSec() << "s" << std::endl;



    std::cout << "* Computing DDM differences..." << std::flush;
    timer.start();

    this->raw_ddm_width = stack->aoi_width/2+1;
    this->raw_ddm_height = stack->aoi_height;

    this->raw_ddm_buffer = fftwf_alloc_real(this->options.Ntau * this->raw_ddm_size());

    if(this->options.doLogScale) {
        #ifdef __AVX2__
                this->ddm_loop_log_avx(this->raw_ddm_buffer,
                                      stack_fft, this->raw_ddm_size(),
                                      delays_filtered, this->options);
        #else
                this->ddm_loop_log_autovec(this->raw_ddm_buffer,
                                          stack_fft, raw_ddm_size(),
                                          delays_filtered, this->options);
        #endif
            } else {
        #ifdef __AVX2__
                this->ddm_loop_avx(this->raw_ddm_buffer,
                                  stack_fft, this->raw_ddm_size(),
                                  this->options);
        #else
                this->ddm_loop_autovec(this->raw_ddm_buffer,
                                      stack_fft, this->raw_ddm_size(),
                                      this->options);
        #endif
    }
    std::cout << "          " << timer.elapsedSec() << "s" << std::endl;

    std::cout << "* Mirroring DDM images ..." << std::flush;
    timer.start();

    this->ddm_width = (this->raw_ddm_width * 2) - 1;
    this->ddm_height = (this->raw_ddm_height)+1;
    this->ddm_buffer = fftwf_alloc_real(this->options.Ntau * this->ddm_size());

    this->ddmshift();
    std::cout << "              " << timer.elapsedSec() << "s" << std::endl;

    fftwf_cleanup_threads();
    fftwf_destroy_plan(plan);
    fftwf_free(stack_fft);
}

void DDM::save_ddm_buffer(std::string path) {

    /**
     * Comment generated by GPT-3
     *
     * Save the DDM buffer to a series of TIFF files.
     *
     * This function writes the DDM buffer, containing multiple frames of the DDM, to a series of TIFF files.
     * Each frame corresponds to a different delay in the DDM. The files are saved in a specified path.
     *
     * @param path The path where the TIFF files will be saved.
     *
     * @throws std::runtime_error if unable to write files.
     *
     * Details:
     *   - Uses the TinyTIFFWriter library to create and write TIFF files.
     *   - The DDM buffer is assumed to be stored in row-major order.
     *   - Each frame of the DDM corresponds to a different delay in the DDM.
     *   - The pixel format is set to 32-bit float for each TIFF file.
     *   - The function prints the time taken for the writing operation.
     */

    Timer timer;
    std::cout << "* Writing files ..." << std::flush;
    timer.start();

    TinyTIFFWriterFile* tif = TinyTIFFWriter_open(path.c_str(), 32, TinyTIFFWriter_Float,
                                                  1, this->ddm_width, this->ddm_height,
                                                  TinyTIFFWriter_Greyscale);
    if(!tif)
        throw std::runtime_error("Can't write files");

    for(int frame = 0; frame < this->options.Ntau; frame++) {
        float* data = &this->ddm_buffer[frame * this->ddm_size()];
        TinyTIFFWriter_writeImage(tif, data);
    }

    timer.stop();
    std::cout << "                     " << timer.elapsedSec() << "s" << std::endl;

    TinyTIFFWriter_close(tif);
}

void DDM::ddmshift() {

    /**
     * Comment generated by GPT-3
     *
     * Perform a shift operation on the raw DDM images.
     *
     * After computing the DDM using appropriate methods (e.g., DDM::ddm_loop_avx), the "raw DDM images" exhibit
     * symmetries due to the Fourier transform, resulting in "fft lobes" in the corners of the image. The width of
     * the raw DDM is half the width of the real input signal plus 1, while the height remains the same.
     *
     * The goal of this function is to transform the raw DDM into a square image with the zero frequency centered.
     * To achieve this, the function operates on a buffer of odd width and height, referred to as ddm.
     *
     * The shift operation involves copying and mirroring regions of the raw DDM to construct the final ddm buffer.
     *
     *                ┌───┐    ┌────────┐
     *                │ 1 │ -> │ 1'   2'│
     *                │ 4 │ -> │ 4'   3'│
     *                └───┘    └────────┘
     *                beg buf   final buf
     * Operations:
     *   - Copy Region 1 to Region 3'
     *   - Copy Region 4 to Region 2'
     *   - Mirror Region 3' to Region 1' and Region 2' to Region 4'
     *
     * Note : final dimension is odd.
     */

    int Nx_Half = this->raw_ddm_width-1;
    int Nx_Full = 2*Nx_Half + 1;

    int Ny_Half = this->raw_ddm_height/2;
    int Ny_Full = 2*Ny_Half+1;

    auto raw_idx = [&](int i, int j, int k) -> int {
        return i*this->raw_ddm_size() + j*this->raw_ddm_width + k;
    };

    auto idx = [&](int i, int jbis, int kbis) -> int {
        return i*Nx_Full*Ny_Full + jbis*Nx_Full + kbis;
    };

    for(int i = 0; i < this->options.Ntau; i++) {

        // Copy 1 -> 3'
        for(int j = 0; j < (Ny_Half+1); j++) {
            for(int k = 0; k < Nx_Half+1; k++) {
                int jbis = j + Ny_Half;
                int kbis = k + Nx_Half;
                this->ddm_buffer[idx(i,jbis,kbis)] = this->raw_ddm_buffer[raw_idx(i,j,k)];
            }
        }

        // Copy 4 -> 2'
        for(int j = this->raw_ddm_height-Ny_Half; j < this->raw_ddm_height; j++) {
            for(int k = 0; k < Nx_Half+1; k++) {
                int jbis = j-this->raw_ddm_height+Ny_Half;
                int kbis = k+Nx_Half;
                this->ddm_buffer[idx(i,jbis,kbis)] = this->raw_ddm_buffer[raw_idx(i,j,k)];
            }
        }

        // Mirror 3'->1' and 2'->4'
        for(int jbis = 0; jbis < Ny_Full; jbis++) {
            for(int kbis = Nx_Half+1; kbis < Nx_Full; kbis++) {
                int jbisbis = Ny_Full - 1 - jbis;
                int kbisbis = Nx_Full - 1 - kbis;
                this->ddm_buffer[idx(i, jbisbis, kbisbis)] = this->ddm_buffer[idx(i, jbis, kbis)];
            }
        }

    }

}

void DDM::ddm_loop_log_autovec(float* raw_ddm,
                          const fftwf_complex* stack_fft,
                          const int fft_size,
                          std::vector<int> delays,
                          utils::Options &opt) {



    // init
    for(int i = 0; i < fft_size*opt.Ntau; i++)
        raw_ddm[i] = 0;

    #pragma omp parallel for schedule(nonmonotonic:dynamic)
    for(int idx_delay = 0; idx_delay < opt.Ntau; idx_delay++) {
        int t, pix;

        const fftwf_complex *i1, *i2;;
        float* ddm_cur = &raw_ddm[idx_delay * fft_size];

        //update of raw_ddm averages
        for(t = delays[idx_delay]; t < opt.loadNframes; t++) {
            i1 = &stack_fft[t*fft_size];
            i2 = &stack_fft[(t-delays[idx_delay])*fft_size];

            for(pix = 0; pix < fft_size; pix++) // for all pixels
                ddm_cur[pix] +=
                        std::pow(i1[pix][REAL]-i2[pix][REAL], 2.) +
                        std::pow(i1[pix][IMAG]-i2[pix][IMAG], 2.);

        }
    }

    float mean_weight = 1. / ( 2*fft_size * (opt.loadNframes-opt.Ntau) );
    for(int i=0; i<fft_size*opt.Ntau; i++)
        raw_ddm[i] *= mean_weight;
}

void DDM::ddm_loop_log_avx(float* raw_ddm,
                       const fftwf_complex* stack_fft,
                       const int fft_size,
                       std::vector<int> delays,
                       utils::Options &opt) {
#ifdef __AVX2__
    // init
    for(int i = 0; i < fft_size*opt.Ntau; i++)
        raw_ddm[i] = 0;

#pragma omp parallel for schedule(nonmonotonic:dynamic)
    for(int idx_delay = 0; idx_delay < opt.Ntau; idx_delay++) {
        int t, pix;
        const float *i1, *i2;

        float* ddm_cur = &raw_ddm[idx_delay * fft_size];

        // AVX and SSE registers for calculations
        __m256 avx_a, avx_b, avx_c;
        __m128 sse_a, sse_b, sse_c;
        const auto perm = _mm256_set_epi32(7,5,3,1,6,4,2,0);

        for(t = delays[idx_delay]; t < opt.loadNframes; t++) {
            i1 = static_cast<const float*>(&stack_fft[t*fft_size][0]);
            i2 = static_cast<const float*>(&stack_fft[(t-delays[idx_delay])*fft_size][0]);
            for(pix=0; pix<fft_size; pix+=4) {
                avx_a = _mm256_load_ps(&i1[2*pix]);
                avx_b = _mm256_load_ps(&i2[2*pix]);
                avx_c = _mm256_sub_ps(avx_a, avx_b);
                avx_a = _mm256_permutevar8x32_ps(avx_c, perm);

                sse_a = _mm_load_ps(&ddm_cur[pix]);
                sse_b = _mm256_extractf128_ps(avx_a, 0);
                sse_c = _mm_fmadd_ps(sse_b, sse_b, sse_a);
                sse_a = _mm256_extractf128_ps(avx_a, 1);
                sse_b = _mm_fmadd_ps(sse_a, sse_a, sse_c);
                _mm_store_ps(&ddm_cur[pix], sse_b);
            }
        }
    }

    float mean_weight = 1. / ( 2*fft_size * (opt.loadNframes-opt.Ntau) );
    for(int i=0; i<fft_size*opt.Ntau; i++)
        raw_ddm[i] *= mean_weight;

#else
    throw std::runtime_error("Your cpu doesn't support AVX2");
#endif
}

void DDM::ddm_loop_autovec(float* raw_ddm,
                      const fftwf_complex* stack_fft,
                      const int fft_size,
                      utils::Options &opt) {
    int tau_max = opt.Ntau;
    int N_frames =  opt.loadNframes;

    for(int i=0; i<fft_size*tau_max; i++)
        raw_ddm[i] = 0;

    // parallelize on every tau, and let the compiler vectorize the code as much as
    // possible
#pragma omp parallel for schedule(nonmonotonic:dynamic)
    for(int tau = 0; tau < tau_max; tau++) {
        // stack indices
        int t, pix;

        // shortcut ptrs
        const fftwf_complex *i1, *i2;
        float* ddm_cur = &raw_ddm[tau * fft_size];

        // Update of raw_ddm averages
        for(t = tau_max; t < N_frames; t++) { // for all times
            i1 =  &stack_fft[t *fft_size];
            i2 =  &stack_fft[(t-tau-1) * fft_size];

            for(pix = 0; pix < fft_size; pix++) // for all pixels
                ddm_cur[pix] +=
                        std::pow(i1[pix][REAL]-i2[pix][REAL], 2.) +
                        std::pow(i1[pix][IMAG]-i2[pix][IMAG], 2.);
        }
    }

    float mean_weight = 1. / ( 2*fft_size * (N_frames-tau_max) );
    for(int i=0; i<fft_size*tau_max; i++)
        raw_ddm[i] *= mean_weight;
}


void DDM::ddm_loop_avx(float* raw_ddm,
                       const fftwf_complex* stack_fft,
                       const int fft_size,
                       utils::Options &opt) {

#ifdef __AVX2__
    int tau_max = opt.Ntau;
    int N_frames =  opt.loadNframes;

    for(int i=0; i<fft_size*tau_max; i++)
        raw_ddm[i] = 0;

#pragma omp parallel for schedule(nonmonotonic:dynamic)
    for(int tau=0; tau<tau_max; tau++) {
        int t, pix;
        const float *i1, *i2;
        float* ddm_cur = &raw_ddm[tau * fft_size];

        // AVX and SSE registers for calculations
        __m256 avx_a, avx_b, avx_c;
        __m128 sse_a, sse_b, sse_c;
        const auto perm = _mm256_set_epi32(7,5,3,1,6,4,2,0);

        for(t=tau_max; t<N_frames; t++) {
            i1 = static_cast<const float*>(&stack_fft[t*fft_size][0]);
            i2 = static_cast<const float*>(&stack_fft[(t-tau-1)*fft_size][0]);
            for(pix=0; pix<fft_size; pix+=4) {
                avx_a = _mm256_load_ps(&i1[2*pix]);
                avx_b = _mm256_load_ps(&i2[2*pix]);
                avx_c = _mm256_sub_ps(avx_a, avx_b);
                avx_a = _mm256_permutevar8x32_ps(avx_c, perm);

                sse_a = _mm_load_ps(&ddm_cur[pix]);
                sse_b = _mm256_extractf128_ps(avx_a, 0);
                sse_c = _mm_fmadd_ps(sse_b, sse_b, sse_a);
                sse_a = _mm256_extractf128_ps(avx_a, 1);
                sse_b = _mm_fmadd_ps(sse_a, sse_a, sse_c);
                _mm_store_ps(&ddm_cur[pix], sse_b);
            }
        }
    }

    float mean_weight = 1. / ( 2 * fft_size * (N_frames-tau_max) );
    for(int i=0; i<fft_size*tau_max; i++)
        raw_ddm[i] *= mean_weight;
#else
    throw std::runtime_error("Your cpu doesn't support AVX2");
#endif
}
