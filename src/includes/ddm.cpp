#include "ddm.hpp"
#include "utils.hpp"
#include "timer.hpp"

#include <immintrin.h>
#include <tinytiffwriter.h>
#include <omp.h>
#include <fftw3.h>

#include <ranges>
#include <iostream>


template<typename T>
DDM<T>::DDM(Stack *stack, Delays<T>& delays, utils::Options& options) :  options(options), delays(delays), stack(stack){
    /**
     * Comment generated by GPT-3
     *
     * Construct a DDM (Differential Dynamic Microscopy) object using a Stack and specified options.
     *
     * This constructor initializes a DDM object based on the provided Stack, Delays, and options. It performs the following steps:
     *   1. Initializes FFTW (Fastest Fourier Transform in the West) threads and sets the number of threads.
     *   2. Creates an FFTW plan for the given Stack, performing a real-to-complex discrete Fourier transform (DFT).
     *   3. Computes DDM differences using the FFT results, considering options such as log scale and vectorization.
     *   4. Shifts the DDM images to center the zero frequency, resulting in a square DDM buffer.
     *
     * @param stack A pointer to the Stack object containing input data.
     * @param delays Reference to the Delays structure specifying the time delays for DDM computation.
     * @param options Reference to the Options structure specifying parameters for DDM computation.
     *
     * Details:
     *   - Uses FFTW for efficient Fourier transforms.
     *   - The DDM buffer dimensions depend on the options and input Stack dimensions.
     *   - The DDM differences are computed based on options, considering log scale and vectorization.
     *   - The final DDM buffer is shifted to center the zero frequency.
     */
    computeFFT();
    computeDDM();
    ddmshift();
}

template<typename T>
DDM<T>::~DDM() {
    fftwf_free(stack_fft);
}

template <typename T>
void DDM<T>::computeFFT() {
    /**
     * Comment generated by GPT-3
     *
     * Compute the Fast Fourier Transform (FFT) for the DDM object.
     *
     * This function creates an FFTW plan, initializes FFTW threads, and computes the FFT for the given Stack.
     * It performs the following steps:
     *   1. Initializes FFTW threads and sets the number of threads.
     *   2. Creates an FFTW plan for the Stack, performing a real-to-complex discrete Fourier transform (DFT).
     *   3. Allocates memory for the complex FFT result based on Stack dimensions and options.
     *   4. Executes the FFT plan to compute the FFT for the input Stack.
     *   5. Cleans up FFTW threads and destroys the FFT plan.
     *
     * @tparam T Template parameter specifying the data type.
     */
    Timer timer;
    std::cout << "* Creating FFTW plan with " << omp_get_max_threads() << " threads..." << std::flush;

    int r = fftwf_init_threads();
    if(r == 0)
        throw std::runtime_error("Can't spawn threads");

    timer.start();
    fftwf_plan_with_nthreads(omp_get_max_threads());

    int rank = 2;

    int n_in[] = {stack->aoi_height, stack->aoi_width};
    int n_out[] = {stack->aoi_height, stack->aoi_width/2+1};

    this->fft_size = n_out[0]*n_out[1];

    this->stack_fft  = fftwf_alloc_complex(fft_size * options.loadNframes);
    fftwf_plan plan = fftwf_plan_many_dft_r2c(rank, n_in, options.loadNframes,
                                              stack->images, n_in,
                                              1, stack->image_size,
                                              stack_fft, n_out,
                                              1, fft_size,
                                              FFTW_ESTIMATE);
    std::cout << "  " << timer.elapsedSec() << "s" << std::endl;


    std::cout << "* Performing DFT..." << std::flush;
    timer.start();
    fftwf_execute(plan);
    std::cout << "                     " << timer.elapsedSec() << "s" << std::endl;

    fftwf_cleanup_threads();
    fftwf_destroy_plan(plan);
}

template <typename T>
void DDM<T>::computeDDM() {
    /**
     * Comment generated by GPT-3
     *
     * Compute the Differential Dynamic Microscopy (DDM) differences for the DDM object.
     *
     * This function computes the DDM differences based on the FFT results and Delays information.
     * It performs the following steps:
     *   1. Initializes variables for the width, height, and buffer size of the raw DDM.
     *   2. Allocates memory for the raw DDM buffer based on Delays information.
     *   3. Computes DDM differences using optimized loops based on available vectorization (AVX2 or autovectorization).
     *
     * @tparam T Template parameter specifying the data type.
     */
    Timer timer;
    std::cout << "* Computing DDM differences..." << std::flush;
    timer.start();

    this->raw_ddm_width = stack->aoi_width/2+1;
    this->raw_ddm_height = stack->aoi_height;

    this->raw_ddm_buffer = fftwf_alloc_real(delays.getIndex().size() * raw_ddm_size());


#ifdef __AVX2__
    ddm_loop_avx_delays();
#else
    ddm_loop_autovec_delays();
#endif
    std::cout << "          " << timer.elapsedSec() << "s" << std::endl;
}


template<typename T>
void DDM<T>::save() {
    /**
     * Comment generated by GPT-3
     *
     * Save the computed Differential Dynamic Microscopy (DDM) data to file.
     *
     * This function writes the DDM data to a file using the TinyTIFFWriter library.
     * It performs the following steps:
     *   1. Initializes a timer to measure the duration of the file-writing process.
     *   2. Opens a TinyTIFFWriter file with the specified output path, data type, dimensions, and format.
     *   3. Iterates through each frame of the DDM buffer and writes the data to the TinyTIFFWriter file.
     *   4. Closes the TinyTIFFWriter file after writing all frames.
     *
     * @tparam T Template parameter specifying the data type.
     */
    Timer timer;
    std::cout << "* Writing files ..." << std::flush;
    timer.start();

    TinyTIFFWriterFile* tif = TinyTIFFWriter_open(options.pathOutput.c_str(), 32, TinyTIFFWriter_Float,
                                                  1, ddm_width, ddm_height,
                                                  TinyTIFFWriter_Greyscale);
    if(!tif)
        throw std::runtime_error("Can't write files");

    for(int frame = 0; frame < delays.getIndex().size(); frame++) {
        float* data = &ddm_buffer[frame * this->ddm_size()];
        TinyTIFFWriter_writeImage(tif, data);
    }

    timer.stop();
    std::cout << "                     " << timer.elapsedSec() << "s" << std::endl;

    TinyTIFFWriter_close(tif);
}



template<typename T>
void DDM<T>::ddmshift() {

    /**
     * Comment generated by GPT-3
     *
     * Perform a shift operation on the raw DDM images.
     *
     * After computing the DDM using appropriate methods (e.g., DDM::ddm_loop_avx), the "raw DDM images" exhibit
     * symmetries due to the Fourier transform, resulting in "fft lobes" in the corners of the image. The width of
     * the raw DDM is half the width of the real input signal plus 1, while the height remains the same.
     *
     * The goal of this function is to transform the raw DDM into a square image with the zero frequency centered.
     * To achieve this, the function operates on a buffer of odd width and height, referred to as ddm.
     *
     * The shift operation involves copying and mirroring regions of the raw DDM to construct the final ddm buffer.
     *
     *                ┌───┐    ┌────────┐
     *                │ 1 │ -> │ 1'   2'│
     *                │ 4 │ -> │ 4'   3'│
     *                └───┘    └────────┘
     *                beg buf   final buf
     * Operations:
     *   - Copy Region 1 to Region 3'
     *   - Copy Region 4 to Region 2'
     *   - Mirror Region 3' to Region 1' and Region 2' to Region 4'
     *
     * Note : final dimension is odd.
     *
     * @tparam T Template parameter specifying the data type.
     */

    Timer timer;

    std::cout << "* Mirroring DDM images ..." << std::flush;
    timer.start();

    this->ddm_width = (raw_ddm_width * 2) - 1;
    this->ddm_height = (raw_ddm_height)+1;
    this->ddm_buffer = fftwf_alloc_real(delays.getIndex().size() * ddm_size());

    int Nx_Half = raw_ddm_width-1;
    int Nx_Full = 2*Nx_Half + 1;

    int Ny_Half = raw_ddm_height/2;
    int Ny_Full = 2*Ny_Half+1;

    auto raw_idx = [&](int i, int j, int k) -> int {
        return i*raw_ddm_size() + j*raw_ddm_width + k;
    };

    auto idx = [&](int i, int jbis, int kbis) -> int {
        return i*Nx_Full*Ny_Full + jbis*Nx_Full + kbis;
    };

    for(int i = 0; i < delays.getIndex().size(); i++) {

        // Copy 1 -> 3'
        for(int j = 0; j < (Ny_Half+1); j++) {
            for(int k = 0; k < Nx_Half+1; k++) {
                int jbis = j + Ny_Half;
                int kbis = k + Nx_Half;
                ddm_buffer[idx(i,jbis,kbis)] = raw_ddm_buffer[raw_idx(i,j,k)];
            }
        }

        // Copy 4 -> 2'
        for(int j = raw_ddm_height-Ny_Half; j < raw_ddm_height; j++) {
            for(int k = 0; k < Nx_Half+1; k++) {
                int jbis = j-raw_ddm_height+Ny_Half;
                int kbis = k+Nx_Half;
                ddm_buffer[idx(i,jbis,kbis)] = raw_ddm_buffer[raw_idx(i,j,k)];
            }
        }

        // Mirror 3'->1' and 2'->4'
        for(int jbis = 0; jbis < Ny_Full; jbis++) {
            for(int kbis = Nx_Half+1; kbis < Nx_Full; kbis++) {
                int jbisbis = Ny_Full - 1 - jbis;
                int kbisbis = Nx_Full - 1 - kbis;
                ddm_buffer[idx(i, jbisbis, kbisbis)] = ddm_buffer[idx(i, jbis, kbis)];
            }
        }

    }

    std::cout << "              " << timer.elapsedSec() << "s" << std::endl;
}

template <typename T>
void DDM<T>::ddm_loop_avx_delays() {
    /**
     * Comment generated by GPT-3
     *
     * Perform the DDM (Differential Dynamic Microscopy) computation using AVX instructions and Delays information.
     *
     * This function computes the DDM differences based on the FFT results, utilizing AVX instructions for vectorization.
     * It performs the following steps:
     *   1. Initializes the raw DDM buffer to zeros.
     *   2. Utilizes AVX2 instructions for parallelized DDM computation.
     *   3. Computes squared differences and accumulates them in the raw DDM buffer.
     *   4. Normalizes the raw DDM buffer by the mean weight.
     *
     * @tparam T Template parameter specifying the data type.
     */
#ifdef __AVX2__
    // init
    for(int i = 0; i < fft_size*delays.getIndex().size(); i++)
        raw_ddm_buffer[i] = 0;

#pragma omp parallel for schedule(nonmonotonic:dynamic)
    for(int idx_delay = 0; idx_delay < delays.getIndex().size(); idx_delay++) {
        int t, pix;
        const float *i1, *i2;

        float* ddm_cur = &raw_ddm_buffer[idx_delay * fft_size];

        // AVX and SSE registers for calculations
        __m256 avx_a, avx_b, avx_c;
        __m128 sse_a, sse_b, sse_c;
        const auto perm = _mm256_set_epi32(7,5,3,1,6,4,2,0);

        for(t = delays.getIndex().back(); t < options.loadNframes; t++) {
            i1 = static_cast<const float*>(&stack_fft[t*fft_size][0]);
            i2 = static_cast<const float*>(&stack_fft[(t-delays.getIndex()[idx_delay])*fft_size][0]);
            for(pix=0; pix<fft_size; pix+=4) {
                avx_a = _mm256_load_ps(&i1[2*pix]);
                avx_b = _mm256_load_ps(&i2[2*pix]);
                avx_c = _mm256_sub_ps(avx_a, avx_b);
                avx_a = _mm256_permutevar8x32_ps(avx_c, perm);

                sse_a = _mm_load_ps(&ddm_cur[pix]);
                sse_b = _mm256_extractf128_ps(avx_a, 0);
                sse_c = _mm_fmadd_ps(sse_b, sse_b, sse_a);
                sse_a = _mm256_extractf128_ps(avx_a, 1);
                sse_b = _mm_fmadd_ps(sse_a, sse_a, sse_c);
                _mm_store_ps(&ddm_cur[pix], sse_b);
            }
        }
    }

    float mean_weight = 1. / ( 2*fft_size * (options.loadNframes-delays.getIndex().size()) );
    for(int i=0; i<fft_size*delays.getIndex().size(); i++)
        raw_ddm_buffer[i] *= mean_weight;

#else
    throw std::runtime_error("Your cpu doesn't support AVX2");
#endif
}

template <typename T>
void DDM<T>::ddm_loop_autovec_delays() {
    /**
     * Comment generated by GPT-3
     *
     * Perform the DDM (Differential Dynamic Microscopy) computation using autovectorization and Delays information.
     *
     * This function computes the DDM differences based on the FFT results, utilizing autovectorization for parallelization.
     * It performs the following steps:
     *   1. Initializes the raw DDM buffer to zeros.
     *   2. Utilizes autovectorization for parallelized DDM computation.
     *   3. Computes squared differences and accumulates them in the raw DDM buffer.
     *   4. Normalizes the raw DDM buffer by the mean weight.
     *
     * @tparam T Template parameter specifying the data type.
     */
    // init
    for(int i = 0; i < raw_ddm_size() * delays.getIndex().size(); i++)
        raw_ddm_buffer[i] = 0;

#pragma omp parallel for schedule(nonmonotonic:dynamic)
    for(int idx_delay = 0; idx_delay < delays.getIndex().size(); idx_delay++) {
        int t, pix;

        const fftwf_complex *i1, *i2;;
        float* ddm_cur = &raw_ddm_buffer[idx_delay * fft_size];

        //update of raw_ddm averages
        for(t = delays.getIndex().back(); t < options.loadNframes; t++) {
            i1 = &stack_fft[t*fft_size];
            i2 = &stack_fft[(t-delays.getIndex()[idx_delay])*fft_size];

            for(pix = 0; pix < fft_size; pix++) // for all pixels
                ddm_cur[pix] +=
                        std::pow(i1[pix][REAL] - i2[pix][REAL], 2.) +
                        std::pow(i1[pix][IMAG] - i2[pix][IMAG], 2.);

        }
    }

    float mean_weight = 1. / ( 2*fft_size * (options.loadNframes-delays.getIndex().size()) );
    for(int i=0; i<fft_size*delays.getIndex().size(); i++)
        raw_ddm_buffer[i] *= mean_weight;
}

template class DDM<float>;
template class DDM<double>;
