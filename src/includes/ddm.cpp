#include "ddm.hpp"

#include <tinytiffwriter.h>
#include <omp.h>
#include <fftw3.h>

#include <ranges>
#include <iostream>
#include <vector>

#include "utils.hpp"
#include "timer.hpp"

// À faire
// - Clean dans le destructor
// - -n buggy
//




DDM::DDM(Stack* stack, utils::lspace<double> delays, utils::Options& options) : options(*(new utils::Options)) {

    /**
     * Comment generated by GPT-3
     *
     * Construct a DDM object using a Stack and specified options.
     *
     * This constructor initializes a DDM object based on the provided Stack and options. It performs the following steps:
     *   1. Initializes FFTW threads and sets the number of threads.
     *   2. Creates an FFTW plan for the given Stack, performing a real-to-complex discrete Fourier transform (DFT).
     *   3. Computes DDM differences using the FFT results, considering options such as log scale and vectorization.
     *   4. Mirrors DDM images to center the zero frequency, resulting in a square DDM buffer.
     *
     * @param stack A pointer to the Stack object containing input data.
     * @param options Reference to the Options structure specifying parameters for DDM computation.
     *
     * Details:
     *   - Uses FFTW for efficient Fourier transforms.
     *   - The DDM buffer dimensions depend on the options and input Stack dimensions.
     *   - The DDM differences are computed based on options, considering log scale and vectorization.
     *   - The final DDM buffer is mirrored to center the zero frequency.
     */

    Timer timer;
    this->options = options;
    this->delays = delays;

    std::cout << "* Creating FFTW plan with " << omp_get_max_threads() << " threads..." << std::flush;

    int r = fftwf_init_threads();
    if(r == 0)
        throw std::runtime_error("Can't spawn threads");

    timer.start();
    fftwf_plan_with_nthreads(omp_get_max_threads());

    int rank = 2;

    int n_in[] = {stack->aoi_height, stack->aoi_width};
    int n_out[] = {stack->aoi_height, stack->aoi_width/2+1};

    this->fft_size = n_out[0]*n_out[1];

    this->stack_fft  = fftwf_alloc_complex(fft_size * options.loadNframes);
    fftwf_plan plan = fftwf_plan_many_dft_r2c(rank, n_in, options.loadNframes,
                                              stack->images, n_in,
                                              1, stack->image_size,
                                              stack_fft, n_out,
                                              1, fft_size,
                                              FFTW_ESTIMATE);
    std::cout << "  " << timer.elapsedSec() << "s" << std::endl;


    std::cout << "* Performing DFT..." << std::flush;
    timer.start();
    fftwf_execute(plan);
    std::cout << "                     " << timer.elapsedSec() << "s" << std::endl;


    std::cout << "* Computing DDM differences..." << std::flush;
    timer.start();

    this->raw_ddm_width = stack->aoi_width/2+1;
    this->raw_ddm_height = stack->aoi_height;

    this->raw_ddm_buffer = fftwf_alloc_real(options.Ntau * raw_ddm_size());


#ifdef __AVX2__
    ddm_loop_avx_delays();
#else
    ddm_loop_autovec_delays();
#endif

    std::cout << "          " << timer.elapsedSec() << "s" << std::endl;

    std::cout << "* Mirroring DDM images ..." << std::flush;
    timer.start();

    this->ddm_width = (this->raw_ddm_width * 2) - 1;
    this->ddm_height = (this->raw_ddm_height)+1;
    this->ddm_buffer = fftwf_alloc_real(this->options.Ntau * this->ddm_size());

    ddmshift();
    std::cout << "              " << timer.elapsedSec() << "s" << std::endl;

    fftwf_cleanup_threads();
    fftwf_destroy_plan(plan);
    //fftwf_free(this->stack_fft);
}



void DDM::save_ddm_buffer(std::string path) {

    /**
     * Comment generated by GPT-3
     *
     * Save the DDM buffer to a series of TIFF files.
     *
     * This function writes the DDM buffer, containing multiple frames of the DDM, to a series of TIFF files.
     * Each frame corresponds to a different delay in the DDM. The files are saved in a specified path.
     *
     * @param path The path where the TIFF files will be saved.
     *
     * @throws std::runtime_error if unable to write files.
     *
     * Details:
     *   - Uses the TinyTIFFWriter library to create and write TIFF files.
     *   - The DDM buffer is assumed to be stored in row-major order.
     *   - Each frame of the DDM corresponds to a different delay in the DDM.
     *   - The pixel format is set to 32-bit float for each TIFF file.
     *   - The function prints the time taken for the writing operation.
     */

    Timer timer;
    std::cout << "* Writing files ..." << std::flush;
    timer.start();

    TinyTIFFWriterFile* tif = TinyTIFFWriter_open(path.c_str(), 32, TinyTIFFWriter_Float,
                                                  1, this->ddm_width, this->ddm_height,
                                                  TinyTIFFWriter_Greyscale);
    if(!tif)
        throw std::runtime_error("Can't write files");

    for(int frame = 0; frame < this->options.Ntau; frame++) {
        float* data = &this->ddm_buffer[frame * this->ddm_size()];
        TinyTIFFWriter_writeImage(tif, data);
    }

    timer.stop();
    std::cout << "                     " << timer.elapsedSec() << "s" << std::endl;

    TinyTIFFWriter_close(tif);
}



void DDM::ddmshift() {

    /**
     * Comment generated by GPT-3
     *
     * Perform a shift operation on the raw DDM images.
     *
     * After computing the DDM using appropriate methods (e.g., DDM::ddm_loop_avx), the "raw DDM images" exhibit
     * symmetries due to the Fourier transform, resulting in "fft lobes" in the corners of the image. The width of
     * the raw DDM is half the width of the real input signal plus 1, while the height remains the same.
     *
     * The goal of this function is to transform the raw DDM into a square image with the zero frequency centered.
     * To achieve this, the function operates on a buffer of odd width and height, referred to as ddm.
     *
     * The shift operation involves copying and mirroring regions of the raw DDM to construct the final ddm buffer.
     *
     *                ┌───┐    ┌────────┐
     *                │ 1 │ -> │ 1'   2'│
     *                │ 4 │ -> │ 4'   3'│
     *                └───┘    └────────┘
     *                beg buf   final buf
     * Operations:
     *   - Copy Region 1 to Region 3'
     *   - Copy Region 4 to Region 2'
     *   - Mirror Region 3' to Region 1' and Region 2' to Region 4'
     *
     * Note : final dimension is odd.
     */

    int Nx_Half = raw_ddm_width-1;
    int Nx_Full = 2*Nx_Half + 1;

    int Ny_Half = raw_ddm_height/2;
    int Ny_Full = 2*Ny_Half+1;

    auto raw_idx = [&](int i, int j, int k) -> int {
        return i*raw_ddm_size() + j*raw_ddm_width + k;
    };

    auto idx = [&](int i, int jbis, int kbis) -> int {
        return i*Nx_Full*Ny_Full + jbis*Nx_Full + kbis;
    };

    for(int i = 0; i < options.Ntau; i++) {

        // Copy 1 -> 3'
        for(int j = 0; j < (Ny_Half+1); j++) {
            for(int k = 0; k < Nx_Half+1; k++) {
                int jbis = j + Ny_Half;
                int kbis = k + Nx_Half;
                ddm_buffer[idx(i,jbis,kbis)] = raw_ddm_buffer[raw_idx(i,j,k)];
            }
        }

        // Copy 4 -> 2'
        for(int j = raw_ddm_height-Ny_Half; j < raw_ddm_height; j++) {
            for(int k = 0; k < Nx_Half+1; k++) {
                int jbis = j-raw_ddm_height+Ny_Half;
                int kbis = k+Nx_Half;
                ddm_buffer[idx(i,jbis,kbis)] = raw_ddm_buffer[raw_idx(i,j,k)];
            }
        }

        // Mirror 3'->1' and 2'->4'
        for(int jbis = 0; jbis < Ny_Full; jbis++) {
            for(int kbis = Nx_Half+1; kbis < Nx_Full; kbis++) {
                int jbisbis = Ny_Full - 1 - jbis;
                int kbisbis = Nx_Full - 1 - kbis;
                ddm_buffer[idx(i, jbisbis, kbisbis)] = ddm_buffer[idx(i, jbis, kbis)];
            }
        }

    }
}

