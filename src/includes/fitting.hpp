#ifndef FITTING_HPP
#define FITTING_HPP

#include "stack.hpp"
#include "curve_fit.hpp"
#include "utils.hpp"

#include <cmath>
#include <vector>
#include <fftw3.h>
#include <algorithm>
#include <iostream>
#include <tinytiffwriter.h>




namespace fit {
    template<typename Callable>
    int find_ROI(Callable fn, float* ddm, int ddm_width, int ddm_height,
                 utils::Options &opt, float sampling_time) {
        /**
         * Comment generated by GPT-3
         *
         * This function aims to determine the maximum acceptable frequency along the delay axis (tau) for fitting data.
         * It selects the largest distance, from the center, along tau by analyzing the kx direction. The analysis involves fitting
         * the data using a user-provided Callable function and identifying the maximum acceptable frequency based on
         * the specified options.
         *
         * Parameters:
         *   - fn: Callable function for curve fitting.
         *   - ddm: Pointer to the 2D DDM array.
         *   - ddm_width: Width of the DDM array.
         *   - ddm_height: Height of the DDM array.
         *   - opt: Reference to an options object containing parameters such as Ntau, delayMax, and frequencyThreshold.
         *   - sampling_time: Time interval between samples in the DDM.
         *
         * Returns:
         *   - An integer representing the index of the closest frequency to the relaxation frequency within the kx direction.
         *
         * Details:
         *   - The function calculates log-delays in time and uses them to extract frequencies along the kx direction.
         *   - It performs curve fitting for each kx, considering the user-provided Callable function.
         *   - The maximum acceptable frequency is determined based on the specified frequency threshold.
         *   - The function returns the index of the closest frequency to the relaxation frequency within the kx direction.
         *
         * Note:
         *   - The input Callable function should have the signature `double(std::vector<double>, double)` for fitting.
         *   - The function assumes that the DDM array is stored in a row-major order.
         *   - The time and frequency units are dependent on the sampling_time parameter.
         */

        int Ntau = opt.Ntau;
        float delay_max = opt.delayMax;
        float frequency_threshold = opt.frequencyThreshold;
        int fft_size = ddm_width * ddm_height;


        std::vector<double> time = utils::log_delays_in_time<double>(sampling_time, delay_max, Ntau);
        float relaxation_frequency = sampling_time*frequency_threshold;

        int idx_center = ddm_width/2;

        std::vector<double> frequencies;
        std::vector<double> kx_along_tau;
        for(int ikx = 0; ikx < ddm_width/2; ikx++) {
            kx_along_tau.clear();
            int tmp_idx = idx_center*ddm_width + idx_center + ikx;
            for(int t = 0; t < Ntau; t++) {
                kx_along_tau.push_back(ddm[t * fft_size + tmp_idx]);
            }

            double A = ddm[(Ntau-1)*fft_size + tmp_idx];
            double B = 0.0;
            double f = 1./time[Ntau-1];
            auto res = curve_fit(fn, {A, B, f}, time, kx_along_tau);
            frequencies.push_back(res[2]);
        }

        return utils::closest_index(frequencies.begin(), frequencies.end(), relaxation_frequency);
    }


    template<typename Callable>
    void EXPERIMENTAL_fit_routine_log(Callable fn, Stack* stack,
                         const float* ddm, const int ddm_width, const int ddm_height,
                         std::vector<double> delays, int ROI) {

        int Nt = delays.size();
        int ddm_size  = ddm_width * ddm_height;

        // plus propre d'avoir tout l'objet ou une référencce à la stack?
        double mean_sampling_time = (stack->times[Nt-1] - stack->times[0])/(Nt-1);

        float *parameters = fftwf_alloc_real(ddm_size*3);

        // shortcut ptrs
        float* As = parameters;
        float* Bs  = &parameters[ddm_size];
        float* fs = &parameters[ddm_size* 2];
        double A, B, f;

        // tau_max
        int tau_max = delays.back();

        std::vector<double> I_vals(tau_max);
        double I_min, I_max, I_thresh;
        int tau, iy, ix;

        for(int iy = 0; iy < ddm_height; iy++) {
            for (int ix = 0; ix < ddm_width; ix++) {
                for(tau = 0; tau < delays.size(); tau++)
                    I_vals[tau] = ddm[ix + iy * ddm_width + tau * ddm_size];

                // Estimation of the mode amplitude and noise
                A = I_vals[tau_max - 1];
                B = 0.;

                // Estimation of the relaxation frequency
                I_min = *std::min_element(I_vals.begin(), I_vals.end());
                I_max = *std::max_element(I_vals.begin(), I_vals.end());
                I_thresh = I_min+(I_max-I_min)*(1-std::exp(-1));
                for(tau = 0; tau < tau_max; tau++) {
                    if(I_vals[tau]>I_thresh)
                        break;
                }
                f = 1./delays[tau];

                // Curve fitting
                auto params_fitted = curve_fit(fn, {A, B, f}, delays, I_vals);
                As[ix + iy * ddm_width] = params_fitted[0];
                Bs[ix + iy * ddm_width] = params_fitted[1];
                fs[ix + iy * ddm_width] = params_fitted[2];
            }
        }

        TinyTIFFWriterFile* fit_tiff = TinyTIFFWriter_open("fit.tif", 32, TinyTIFFWriter_Float,
                                                           1, ddm_width, ddm_height,
                                                           TinyTIFFWriter_Greyscale);
        if(!fit_tiff) {
            std::cout << "Can't write fitting parameters into tiff!" << std::endl;
        }

        for(int param = 0; param < 3; param++)
            TinyTIFFWriter_writeImage(fit_tiff, &parameters[param*ddm_size]);
        TinyTIFFWriter_close(fit_tiff);
    }

    template<typename Callable>
    void fit_routine(Callable fn, Stack* stack,
                     const float* ddm, const int ddm_width, const int ddm_height,
                     int tau_max, int fft_size) {
        /**
         * Creates a 3-stacked TIFF images named "fit.tif",
         * containing values of parameters of the exponential fit ;
         * params to be fitted [A->f->B] :  A(1-exp[-tau*f])+B
         */
        int Nt = stack->times.size();
        int ddm_size  = ddm_width * ddm_height;

        double mean_sampling_time = (stack->times[Nt-1] - stack->times[0])/(Nt-1);

        std::vector<double> times;
        for(int tau = 1; tau <= tau_max; tau++)
            times.push_back(tau*mean_sampling_time);

        float *parameters = fftwf_alloc_real(ddm_size*3);

        // shortcut ptrs
        float* As = parameters;
        float* Bs  = &parameters[ddm_size];
        float* fs = &parameters[ddm_size* 2];
        double A, B, f;

        std::vector<double> I_vals(tau_max);
        double I_min, I_max, I_thresh;
        int tau, iy, ix;

        for(int iy = 0; iy < ddm_height; iy++) {
            for (int ix = 0; ix < ddm_width; ix++) {
                for(tau = 0; tau < tau_max; tau++)
                    I_vals[tau] = ddm[ix + iy * ddm_width + tau * ddm_size];

                // Estimation of the mode amplitude and noise
                A = I_vals[tau_max - 1];
                B = 0.;

                // Estimation of the relaxation frequency
                I_min = *std::min_element(I_vals.begin(), I_vals.end());
                I_max = *std::max_element(I_vals.begin(), I_vals.end());
                I_thresh = I_min+(I_max-I_min)*(1-std::exp(-1));
                for(tau = 0; tau < tau_max; tau++) {
                    if(I_vals[tau]>I_thresh)
                        break;
                }
                f = 1./times[tau];

                // Curve fitting
                auto params_fitted = curve_fit(fn, {A, B, f}, times, I_vals);
                As[ix + iy * ddm_width] = params_fitted[0];
                Bs[ix + iy * ddm_width] = params_fitted[1];
                fs[ix + iy * ddm_width] = params_fitted[2];
            }
        }

        TinyTIFFWriterFile* fit_tiff = TinyTIFFWriter_open("fit.tif", 32, TinyTIFFWriter_Float,
                                                           1, ddm_width, ddm_height,
                                                           TinyTIFFWriter_Greyscale);
        if(!fit_tiff) {
            std::cout << "Can't write fitting parameters into tiff!" << std::endl;
        }

        for(int param = 0; param < 3; param++)
            TinyTIFFWriter_writeImage(fit_tiff, &parameters[param*fft_size]);
        TinyTIFFWriter_close(fit_tiff);
    }
}

#endif //FITTING_HPP
