#include "utils.hpp"

#include <string>
#include <vector>
#include <iostream>
#include <cmath>

int utils::stoe(std::string &s) {
    int id = -1;

    if(s == "Mono16")
        id = Mono16;
    if(s == "Mono12")
        id = Mono12;
    if(s == "Mono12Packed")
        id = Mono12Packed;
    if(s == "Mono32")
        id = Mono32;

    return id;
}

template <typename T>
T sqr(T val) {
    return val*val;
}

template<typename InputIterator, typename ValueType>
int utils::closest_index(InputIterator first, InputIterator last, ValueType value)
{
    auto closest_it = std::min_element(first, last, [&](ValueType x, ValueType y)
    {
        return std::abs(x - value) < std::abs(y - value);
    });

    // Calculate the index of the closest element
    return static_cast<int>(std::distance(first, closest_it));
}

template<typename T>
std::vector<T> utils::linspace(T start, T end, int num_points) {
    std::vector<T> result;
    double step = (end-start)/(num_points-1);
    for(int i = 0; i < num_points; i++) {
        double value = start + i*step;
        result.push_back(value);
    }
    return result;
}

template<typename T>
std::vector<T> utils::logspace(T start, T end, int num_points) {
    std::vector<T> result;
    double step = (end - start) / (num_points - 1);
    for (int i = 0; i < num_points; i++) {
        float value = start + i * step;
        result.push_back(std::pow(10, value));
    }
    return result;
}

template<typename T>
utils::lspace<T>* utils::delays(T sampling_time, utils::Options& opt, std::string mode) {

    /**
     * Comment generated by GPT-3
     *
     * This function generates a time-space representation using linear or logarithmic spacing
     * based on the specified mode. It adjusts time values, removes duplicates, and maps time values
     * to corresponding indices.
     *
     * @tparam T Data type for time values.
     * @param sampling_time Sampling time for the time-space representation.
     * @param opt Options containing configuration parameters.
     * @param mode Mode of spacing ("linear" or "logarithmic").
     * @return A pointer to the generated time-space representation.
     * @throws std::runtime_error if the specified mode is invalid.
     */

    auto space = new utils::lspace<T>;


    if(mode == "linear")
        space->time = utils::linspace<T>(0, opt.delayMax, opt.Ntau);
    else if(mode == "logarithmic") {
        space->time = utils::logspace<T>(0, std::log10(opt.delayMax / sampling_time ), opt.Ntau);

        // somewhat an arbitrary decision to stick with literal logscaling (and then start at sampling_time)
        // or to add 0 at the beginning
        // i may move it later
        space->time.insert(space->time.begin(), 0);
        space->index.insert(space->index.begin(), 0);
    }
    else
        throw std::runtime_error("Error : delays(...) : mode doesn't exists");

    if(mode == "logarithmic")
        std::transform(space->time.begin(), space->time.end(), space->time.begin(), [sampling_time](T x) -> T {
            return (T) std::floor(x)*sampling_time;
        });

    auto ittime = std::unique(space->time.begin(), space->time.end());
    space->time.resize(std::distance(space->time.begin(), ittime));


    // serve as initialization before transforming it
    space->index.resize(space->time.size());
    std::transform(space->time.begin(), space->time.end(), space->index.begin(), [sampling_time](T x) -> int {
        return std::floor(x/sampling_time);
    });

    auto itidx =  std::unique(space->index.begin(), space->index.end());
    space->index.resize(std::distance(space->index.begin(), itidx));

    return space;
}
template utils::lspace<float>* utils::delays(float, utils::Options&, std::string);
template utils::lspace<double>* utils::delays(double, utils::Options&, std::string);
